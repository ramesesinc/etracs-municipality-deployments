import com.rameses.annotations.*;
import market.facts.*;
import treasury.facts.*;

class MarketBillScheduleService {

	@Service("RuleExecutorService")
	def ruleSvc;

	@Service(value="HolidayService", connection="enterprise")
	def holidaySvc;

	@Service("DateService")
	def dateSvc;

	@DataContext("market_billschedule")
	def skedEm;	

	@DataContext("market_billgroup")
	def groupEm;	
	
	@ProxyMethod 
	public def getSchedule( p ) {
		if( !p.billgroupid ) throw new Exception("billgroupid is required");
		if( !p.year ) throw new Exception("year is required");
		if( !p.month ) throw new Exception("month is required");
		if( !p.day) p.day = 1;

		def grp = groupEm.find( [objid: p.billgroupid ] ).first();

		def facts = [];
		facts << new MarketBillGroup( id: grp.objid, tag: grp.tag, billtype: grp.billtype  );
		facts << new MarketBillSchedule( year: p.year, month : p.month, day: p.day );

		//include holidays
		facts << new HolidayFact(  
			handler: { dt->
				def h = holidaySvc.lookup(dt);
				return (h!=null);
			}
		);
		ruleSvc.execute( "marketbillingschedule", facts, null, null );

		def billingPeriod = facts.find{ it instanceof MarketBillSchedule };
		if(!billingPeriod) throw new Exception("There are no schedule rules that match the criteria");

		def m = billingPeriod.toMap();
		m.billgroupid = p.billgroupid;
		m.billgroup = [objid: p.billgroupid ];
		def df = new java.text.SimpleDateFormat("yyyyMMdd");
		m.objid = m.billgroupid + df.format( m.fromdate );

		def sked = skedEm.find( [billgroupid: m.billgroupid, year: m.year, month: m.month, fromdate: m.fromdate ] ).first();
		if( !sked ) {
			sked = skedEm.create( m );
			sked =  skedEm.find([objid: sked.objid ]).first();
		}
		return sked;	
	}

	


}