import com.rameses.annotations.*;

import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.services.extended.*;

class WorkflowGUIService {		

    @Service
    def self;

    @DataContext("sys_wf")
    def wf;

	@DataContext("sys_wf_node")
	def wfNode;

	@DataContext("sys_wf_transition")
	def wfTransition;

    @DataContext("sys_wf_eventaction")
    def eventActionEm;

    @ProxyMethod
    public def create( def m ) {
        return wf.create( m );
    }

	@ProxyMethod
	public def getData( def processname ) {
        def data = [:];
        data.info = wf.find( [name: processname ]).first();
        data.processname = processname;
        data.figures = [];
        data.connectors = [];

        def eventactions = eventActionEm.find( [processname: processname ] ).orderBy("index").list();
        def nodeactions = eventactions.findAll{ !it.transitionto };
        def transactions = eventactions.findAll{ it.transitionto != null };

		def states = wfNode.find( [processname: processname ] ).list();
        states.each { 
            def f = [id: it.name];
            f.caption = it.title;
            f.ui = it.remove("ui");
            f.index = it.idx;
            f.info = it;
            if( f.ui == null ) {
                def nui = [text: it.title, type: it.nodetype ];
                nui.pos =  [0,0];
                nui.size =  [100,50];
                f.ui = nui;
            };

            def xname = it.name;
            f.info.beforeactions = nodeactions.findAll{ nn-> ( nn.nodename == xname && nn.eventtype == 'before' && nn.transitionto==null) };
            f.info.afteractions = nodeactions.findAll{ nn-> ( nn.nodename == xname && nn.eventtype == 'after' && nn.transitionto==null) }; 

            if( f.info.beforeactions ) f.caption = "*" + f.caption ;
            if( f.info.afteractions ) f.caption += "*";
            data.figures << f;
        }

		def transitions = wfTransition.find( [processname: processname ] ).list();
        transitions.each {
            def c = [:];
            c.startFigureId = it.parentid;
            c.endFigureId = it.to;
            c.caption = it.action;
            c.ui = it.remove("ui");
            c.info = it;
            if(c.ui == null ) {
                def tui = [type: "arrow"];
                c.ui = tui;
            };

            def _parentid = it.parentid;
            def _to = it.to;
            c.info.beforeactions = transactions.findAll{ nn-> ( nn.nodename == _parentid &&  nn.eventtype == 'before' && nn.transitionto ==_to) };
            c.info.afteractions = transactions.findAll{ nn-> ( nn.nodename == _parentid && nn.eventtype == 'after' && nn.transitionto == _to) }; 

            if( c.info.beforeactions ) c.caption = "*" + c.caption;
            if( c.info.afteractions ) c.caption += "*";            
            data.connectors << c;
        }
        return data;	
	}

    @ProxyMethod
    public void updateNode( def o ) {
        //this needs to be intercepted by the app so we can make the necessary changes
    }    

	@ProxyMethod
	public void save( def data ) {

        //reusable actions
        def removeEventAction = {from,to,type->
            //remove first the event actions if any
            def e = [processname: data.processname ];
            if( from ) e.nodename = from;
            if( type ) e.eventtype = type;
            if(to==null) {
                eventActionEm.find( e ).where("transitionto IS NULL").delete();    
            }
            else {
                eventActionEm.find( e ).where("transitionto = :to", [to: to]).delete();
            }
        }

        def removeTransitions = { from, to ->
            if(!from && !to) return;
            removeEventAction( from, to, null );
            def p = [processname: data.processname ];
            if( from ) p.parentid = from;
            if( to ) p.to = to;
            wfTransition.find( p ).delete();
        }

        def removeNode = { name->
            removeTransitions( name, null );
            removeTransitions( null, name );
            def p = [processname: data.processname ];
            p.name = name;
            wfNode.find( p ).delete();
        }

        def saveEventAction = { dat, type, from, to ->
            dat.processname = data.processname;
            dat.nodename = from;
            dat.eventtype = type;
            if(to) dat.transitionto = to;
            eventActionEm.save( dat );   
        }

        //start deletion of deleted items
        if(data._deletedfigures ) {
            data._deletedfigures.each {
                removeNode( it.id );
            }
        };

        if(data._deletedconnectors ) {
            data._deletedconnectors.each {
                removeTransitions( it.startFigureId, it.endFigureId );
            }
        };
        
        //save the nodes
        def changeMap = [:];

		data.figures.each {
            //if there are deleted event actions, remove it.
            if(it.info._deletedactions ) {
                it.info._deletedactions.each { dd->
                    removeEventAction( dd.nodename, dd.transitionto, dd.eventtype );
                }
            }

            //if node was renamed, must remove all transitions where parentid=oldname && to==oldname
            def vb = null;
            if(it.id != it.info.name ) {
                //old name=>it.id, newname=>it.info.name;
                removeNode( it.id );
                
                //put this in a change map so we can update the connectors.
                changeMap.put( it.id, it.info.name );
                it.id = it.info.name;
            }    
            else {
                vb = wfNode.find( [processname:data.processname, name: it.id] ).first();
            }

            def p = [processname:data.processname, name: it.id];
            def u = it.info;
            u.ui = it.ui;
            u.idx = it.index;

            //println "idx is " + u.idx;

            if(!u.properties) u.properties = [:];
            if( !u.title ) u.title = u.name;
            
            if(vb) {
                wfNode.find( p ).update( u );
            }
            else {
                if( !u.nodetype ) u.nodetype = u.ui.type;
                if(!u.title) u.title = u.nodetype;

                u.processname = data.processname;
                wfNode.create( u );
            }

            //insert event actions
            if(it.info.beforeactions) {
                int idx = 1;
                it.info.beforeactions.each { a->
                    a.index = (idx++);
                    saveEventAction( a, "before", p.name, null );
                }    
            }
            //insert event actions
            if(it.info.afteractions) {
                int idx = 1;
                it.info.afteractions.each { a->
                    a.index = (idx++);
                    saveEventAction( a, "after", p.name, null );
                }    
            }
		}
        
        //push connectors
        data.connectors.each {
            //println "trans " + it.startFigureId + " to " + it.endFigureId + "::info data " + it.info.parentid + " ->" + it.info.to; 
            //if there are deleted event actions, remove it.
            if(it.info._deletedactions ) {
                it.info._deletedactions.each {
                    removeEventAction( it.startFigureId, it.endFigureId, null );
                }
            }

            //check if there is a change of parent
            if( changeMap.containsKey(it.startFigureId) ) {
                def oldNode = it.startFigureId;    
                def newNode = changeMap.get(oldNode); 
                if( it.info.parentid == oldNode ) it.info.parentid = newNode;
                it.startFigureId = newNode;
            }
            //check if there is change of to
            if( changeMap.containsKey(it.endFigureId) ) {
                def oldNode = it.endFigureId;    
                def newNode = changeMap.get(oldNode); 
                if( it.info.to == oldNode ) it.info.to = newNode;
                it.endFigureId = newNode;
            }

            if( it.info.parentid!=null && it.startFigureId != it.info.parentid ) {
                removeTransitions( it.startFigureId, null );
            }
            if( it.info.to!=null && it.endFigureId != it.info.to ) {
                removeTransitions( null, it.endFigureId );
            }

            def p = [parentid: it.startFigureId, to: it.endFigureId, processname: data.processname ];
            def wt = wfTransition.find( p ).first();

            def u = it.info;
            u.ui = it.ui;
            if(!u.properties) u.properties = [:];

            if( wt ) {
                wfTransition.find( p ).update( u );
            }
            else {
                u.processname = data.processname;
                u.parentid = it.startFigureId;
                u.to = it.endFigureId;
                wfTransition.create( u );    
            }

            //save the event actions
            if(it.info.beforeactions) {
                int idx = 1;
                it.info.beforeactions.each { a->
                    a.index = (idx++);
                    saveEventAction( a, "before", p.parentid, p.to );
                }    
            }
            //insert event actions
            if(it.info.afteractions) {
                int idx = 1;
                it.info.afteractions.each { a->
                    a.index = (idx++);
                    saveEventAction( a, "after", p.parentid, p.to );
                }    
            }
		}

        //if there are changes throw to the event so you can react
        if(changeMap) {
            self.updateNode( [processname: data.processname, changes: changeMap ] );
        }
	}

    @ProxyMethod 
    public def openDataForExport(o) {
        def obj = wf.find( [name: o.name ]).first();
        obj.nodes = wfNode.find( [processname: o.name ]).list();
        obj.transitions = wfTransition.find( [processname: o.name ]).list();
        obj.eventactions = eventActionEm.find( [processname: o.name ] ).list();
        return obj;
    }    

    @ProxyMethod 
    public void importData(o) {
        //cleanup first
        def v = [processname: o.name];    
        wfTransition.find( v).delete();
        wfNode.find( v).delete();
        eventActionEm.find( v).delete();

        wf.delete(o); 

        def nodes = o.remove("nodes");
        def transitions = o.remove("transitions");
        def eventactions = o.remove("eventactions");
        wf.create(o);
        nodes.each {
           wfNode.create( it );
        }
        transitions.each {
            wfTransition.create(it);
        }
        eventactions.each {
            eventActionEm.create( it );
        }
    }

    @ProxyMethod
    public void copy( def o ) {
        def target = o.name;
        def source = o.oldname;

        def model = openDataForExport( [name:source]);
        def nodes = model.remove("nodes");
        def transitions = model.remove("transitions");
        def eventactions = model.remove("eventactions");

        model.name = target;
        wf.create( model );

        nodes.each{ 
            it.processname = target; 
            wfNode.create( it );
        };
        transitions.each { 
            it.processname = target;
            wfTransition.create(it); 
        };    
        eventactions.each {
            it.processname = target;
            eventActionEm.create( it );
        }    
    }

    @ProxyMethod
    public void updateTitle( def o ) {
        wf.find( [name: o.name] ).update( o );    
    }    

}
