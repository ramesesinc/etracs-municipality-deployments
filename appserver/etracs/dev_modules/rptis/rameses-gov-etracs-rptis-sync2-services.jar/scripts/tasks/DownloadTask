import com.rameses.annotations.*;
import java.io.File;
import com.rameses.fileupload.*;
import org.apache.commons.lang.exception.ExceptionUtils;
import java.util.concurrent.*;

class DownloadTask {
    @XConnection('fileupload')
    def fu;

    @Service('RPTMainSyncDataService')
    def svc

    @DataContext('rpt_syncdata')
    def em_syncdata

    @DataContext('rpt_syncdata_item')
    def em_sync_item

    @DataContext('rpt_syncdata_error')
    def em_sync_error

    @DataContext('rpt_syncdata_fordownload')
    def em_sync_fordownload

    @Service('Var')
    def var;

    @Service('DateService')
    def dtSvc;

    @DataContext('sys_org')
    def sys_org

    def DOWNLOAD_FLAG = "fileserver_download_task_active"

    /* Download AWS Keys and save to fordownload */
    @Schedule(interval=60)
    public void downloadAwsKeys( evt ) {
        if (!downloaderActive()) return
        
        def fordownloadfile = em_sync_fordownload.where("state = 'FORDOWNLOAD'").first()
        if (fordownloadfile) {
            return;
        }

        try {
            fu.getList().each {
                try {
                    def fordownload = [:];
                    fordownload.objid = it.Key;
                    fordownload.state = 'FORDOWNLOAD';
                    fordownload.etag = it.ETag;
                    fordownload.error = false;
                    em_sync_fordownload.save(fordownload);
                } catch(err) {
                    //ignore
                    err.printStackTrace();
                } 
            }
        } catch ( e ) {
            println "DownlaodTask [ERROR] " + e.message;
        }
    }

    @Schedule(interval=1)
    public void downloadFiles( evt ) {
        if (!downloaderActive()) return

        def fordownloadfiles = em_sync_fordownload.where("state = 'FORDOWNLOAD'").orderBy('objid').list(0, 10)
        if (!fordownloadfiles) {
            waitTimeout(20);
            return;
        }

        fordownloadfiles.each {
            try {
                //download file and save to local storage 
                fu.download(it.objid);

                //delete cloud data
                fu.delete(it.objid);

                em_sync_fordownload.find([objid: it.objid]).update([state: 'DOWNLOADED']);
            } catch(err) {
                try {
                    //try reading the file if existing, update state if downloaded
                    def reader = fu.readObject(it.objid);
                    em_sync_fordownload.find([objid: it.objid]).update([state: 'DOWNLOADED']);
                } catch(ignore) {
                    err.printStackTrace()
                }
            } 
        }
    }

    
    @Schedule(interval=1)
    public void syncDownloadedFile( evt ) {
        def downloadfile = em_sync_fordownload.where("state = 'DOWNLOADED' and error = 0").orderBy('objid').first()
        if (!downloadfile) {
            waitTimeout(10);
            return;
        }

        def reader = null;
        def syncdata = null;
        try {
            reader = fu.readObject(downloadfile.objid);
            syncdata = reader.read();
            syncdata.data = reader.read(); 
            svc.receive(syncdata);

            //save syncdata and item
            syncdata.state = 'FORSYNC';
            syncdata.dtcreated = dtSvc.serverDate;
            syncdata.parent.state = syncdata.state;
            def orgid = syncdata.parent.remote.orgid;
            syncdata.parent.remote = getRemoteOrg(syncdata);
            syncdata.parent.orgid = orgid;
            em_syncdata.save(syncdata.parent);
            em_sync_item.save(syncdata);
            em_sync_fordownload.find([objid: downloadfile.objid]).delete();
            em_sync_error.find([objid: syncdata.objid]).delete();
            reader.deleteFile();
        } catch(java.io.FileNotFoundException iox) {
            log('ERROR', 'Downloaded file not exists: ' + downloadfile.objid);
            em_sync_fordownload.find([objid: downloadfile.objid]).delete();
        } catch (e) {
            log('INFO', e.message)
            e.printStackTrace();
            if (syncdata) {
                syncdata.state = 'FORSYNC'
                syncdata.filekey = downloadfile.objid;
                syncdata.error = ExceptionUtils.getStackTrace(e);
                syncdata.info = syncdata.info ? syncdata.info : [:]
                syncdata.remote = [
                    orgid: syncdata.parent.orgid,
                    orgcode: syncdata.parent.orgid,
                    orgclass: "PROVINCE".equalsIgnoreCase(syncdata.parent.remote?.orgclass) ? "MUNICIPALITY" : "PROVINCE",
                ]
                em_sync_error.save(syncdata);
                em_sync_fordownload.find([objid: downloadfile.objid]).update([error: 1]);
            }
            if (reader) reader.close();
        }
    }

    def downloaderActive() {
        def status = var.getProperty(DOWNLOAD_FLAG, 0).toString();
        if (status.matches("1|y|yes|t|true")) {
            return true;
        }
        log('INFO', 'DownloadTask [INFO] inactive');
        return false;
    }

    def hasFileForDownload() {
        def downloadfile = em_sync_fordownload.where('error = 0').first()
        return downloadfile != null
    }

    void waitTimeout(secs) {
        def queue = new LinkedBlockingQueue();
        queue.poll(secs, TimeUnit.SECONDS);
    }

    def getRemoteOrg(syncdata) {
        def org = sys_org.find([objid: syncdata.parent.orgid]).first();
        return [
            orgid: org?.objid,
            orgcode: org?.code.replaceAll('-', ''),
            orgclass: org.orgclass,
        ]
    }

    void log(type, msg) {
        println 'DownloadTask [' + type + '] ' + msg;
    }
}